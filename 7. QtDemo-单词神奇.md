# 单词神器

单词神器，它将翻译，字典，背单词、文档翻译等功能集成于同一个窗口应用程序

- 我们采用 MVC 模式开发应用程序，实现数据、界面、用户输入输出相分离，降低了模块与模块之间的耦合性；
- 自定义常量管理模块，便于代码的管理与维护

### 项目结构

项目命名为 Translate，包含六个模块，分别是：

- constans：常量管理模块，管理所有界面中的常量
- database：数据库连接 API
- model：用户界面模型，所有的界面都放在此模块下
	- Window.py：基类，定义了左侧公共布局
	- TranslateUI.py：继承 Window 类，翻译界面
	- WordSearchUI.py：继承 Window 类，查字典界面，数据来源于 dictionary 表
	- ReciteWordUI.py：继承 Window 类，背单词界面，数据来源于 wordbook 表
	- TranslateFileUI.py：继承 Window 类，文档翻译界面
- QSSTool：QSS 样式表模块，所有界面的样式表都定义在此模块下
- slot：处理用户与数据库交互的槽函数，所有的数据库操作都在此模块下进行，集中管理
- TranslateAPI：翻译 API

### Python 与 MySQL 数据库交互

##### 安装DB-API
首先要安装 pymysql 模块，**pymysql 中定义了与 MySQL 交互的 API**，pymysql 也是 DB-API 中的一种 API。

`pip install pymysql`

```shell
(qt5env) PS C:\Users\dell> pip install pymysql
Collecting pymysql
  Downloading PyMySQL-1.0.2-py3-none-any.whl (43 kB)
     ---------------------------------------- 43.8/43.8 KB 82.7 kB/s eta 0:00:00
Installing collected packages: pymysql
Successfully installed pymysql-1.0.2
```
##### 通过DB-API  连接MySQL 数据库

- 1. 连接 Mysql 数据库
```python
db_config = {
    'host': '127.0.0.1',
    'port': 3306,       # mysql 的端口是 3306
    'user': 'root',
    'password': 'qwe123',
    'db': 'python51',   # 库名，不加会报错
    'charset': 'utf8',  # 不是 utf-8
}
con = pymsql.connect(**db_config)  # 一定要注意加 **
```

- 2. 操作mysql数据库

<img src=".\fig\7.db-mysql.png" alt="7.db-mysql" style="zoom:80%;" />

使用步骤：

1）导入模块：`import pymsql`
2）建立连接：`con = pymysql.connect(**db_config)`
3）创建游标：`cur = con.cursor()` # 可以用 with 上下文管理
4）执行 mysql 语句：`exc = cur.execute("select * from student")` # exc 是数据的条数
5）获取结果：`values = cur.fetchall()/cur.fetchone()`
6）关闭游标：`cur.close()`
7）提交事务：`con.commit()`
8）关闭连接：`con.close()`

> 注意要点：
> - 在 pymysq| 中执行的 SQL 语句**不需要加分号**
> - execute 执行完后不是直接得到结果，需要**主动获取**
> - 和文件一样，别忘了关闭游标与连接
> - 事务的回滚和提交：rollbck 与 commit


### MVC 框架

##### MVC 框架模式

MVC 全名是 Model View Controller，是模型（model）－视图（view）－控制器（controller）的缩写，是一种非常经典的软件架构模式，在 UI 框架和 UI 设计思路中扮演着非常重要的角色。从设计模式的角度来看，MVC 模式是一种复合模式，它将多个模式设计在一种解决方案中，用来解决许多有关设计方面的问题。MVC 各自的任务如下：

- 模型层：模型含有所有的数据和数据状态
- 视图层：视图通俗说就是展示给用户看的界面，通常直接从数据库模型中取得相关的数据，展示给用户
- 控制层：介于视图和模型中间，负责控制用户输入，经过解析后反馈到模型层；控制数据输出，处理后，展示给用户

MVC 框架模式能够将模型、视图、用户输入输出控制分离来组织代码，将业务逻辑集成到一个模块中，代码具有很强的封装性。MVC 在个性化定制界面功能以及与用户交互的同时，不需要重构业务逻辑。

MVC 开始是存在于桌面程序中的，我们都知道一个高耦合、低内聚的程序一旦出现问题，调试的时候会有各种 BUG，往往需要花费大量的人力、物理、财力去进行维护。使用 MVC 的目的是将 M 和 V 的实现代码分离，从而使同一个程序能够高度模块化，达到代码之间低耦合的目的。C 存在的目的则是确保 M 和 V 的同步，一旦 M 发生改变，V 应该同步更新，或者说 V 发生改变，M 能够及时更新。

<img src=".\fig\7.MVC.png" alt="7.MVC" style="zoom:80%;" />

MVC 框架模式的优点：

- 使程序结构更合理
- 使代码维护更容易
- 使代码复用性更好

##### 框架模式和设计模式的区别：

有很多程序员都把框架模式和设计模式搞混淆了，认为 MVC 是一种设计模式。实际上框架模式和设计模式是完全不同的两个概念。

- **框架模式**模式通常是指**代码重用**，而**设计模式**通常是指**设计重用**，架构则介于二者之间，部分代码重用，部分设计重用。

- 框架模式与设计模式虽然相似，但却有着根本的不同。设计重在“想”，而框架重在“做”。设计模式是对在某种环境中反复出现的问题以及针对该问题的解决方案的描述，它比框架更抽象；**框架**可以用**代码**表示，也能直接执行或复用，它比设计模式更具体。设计模式是框架模式的单元，一个框架中往往含有一种或多种设计模式，框架总是针对某一特定应用领域，但同一种模式却可适用于各种应用。

- 主流的框架模式有：MVC、MTV、MVP、CBD、ORM 等等，这里不做过多的介绍，感兴趣的话大家可以自行百度了解。

- 主流的框架有：QT（C++ 编写）、SSH（java 编写） 、MVC（PHP）、MTV（Django）等等。

- 主流的设计模式有：工厂模式、适配器模式、策略模式等等。

### 构建项目结构

##### 构建项目结构

1. 创建项目目录

```shell
cd /Code

mkdir Translate # 创建项目文件夹
cd Translate    # 在该路劲下创建
```

2. 创建资源管理目录

Translate

- resource
	- figs  	 存放图片资源
	- date 		存放 sql 文件

```shell
mkdir resource
cd resource

mkdir figs  # 存放图片资源
mkdir data  # 存放sql资源
```

3. 创建项目常量管理模块

Translate

- constants
	- \_\_init\_\_.py
	- Constants.py

```shell
cd ..
mkdir constants
cd constants
touch Constants.py
touch __init__.py
```

4. 创建项目数据库API模块

Translate

- database
	- \_\_init\_\_.py
	- database.py

```shell
cd ..
mkdir database
cd database
touch database.py
touch __init__.py
```

5. 创建项目翻译API模块

Translate

- TranslateAPI

```shell
cd ..
mkdir TranslateAPI
```

6. 创建项目槽函数模块

Translate

- slot
	- \_\_init\_\_.py
	- slot.py
	
```shell
mkdir slot
cd slot
touch slot.py
touch __init__.py
```

7. 创建项目视图模块

Translate

- model
	- \_\_init\_\_.py
	- Window.py
	- TranslateUI.py
	- DictTable.py
	- WordSearchUI.py
	- ReciteWordUI.py
	- TranslateFileUI.py

```shell
cd ..
mkdir model
cd model
touch __init__.py
touch Window.py
touch TranslateUI.py
touch DictTable.py
touch WordSearchUI.py
touch ReciteWordUI.py
touch TranslateFileUI.py
```

8. 创建项目QSS模块

Translate

- QSSTool
	- \_\_init\_\_.py
	- QSSTool.py

	- window.qss
	- translate.qss
	- dicttable.qss
	- reciteword.qss
	- translatefile.qss

```shell
cd ..
mkdir QSSTool
cd QSSTool
touch __init__.py
touch QSSTool.py
touch window.qss
touch translate.qss
touch dicttable.qss
touch reciteword.qss
touch translatefile.qss
```

9. 创建程序入口

Translate

- \_\_init\_\_.py
- main.py

##### Linux 查看目录结构图

```shell
pip install tree # 安装 tree 命令
tree 			 # 显示当前目录的目录结构图
```

<img src="fig\7.tree.png" alt="7.tree" style="zoom:80%;" />

### 导入资源 (数据库连接 API)

##### 1. 导入资源 `resource.zip`

- 请将 `translate.png` 移动至线上环境中的项目目录的 `resource/figs` 目录中
- 将 `将进酒.txt` 移动至线上环境中的项目目录的`resource` 目录中
- 将 `wordbook.sql` 和`dictionary.sql` 移动至线上环境中的项目目录的 `resource/data` 目录中
- 将 `translate.py` 和 `__init__.py` 移动至线上环境中的项目目录的 `TranslateAPI` 目录中

```shell
unzip resource.zip

mv resource/*.png Translate/resource/figs/
mv resource/将进酒.txt Translate/resource/
mv resource/*.sql Translate/resource/data/
mv resource/*.py Translate/TranslateAPI/
```

##### 2. 导入 sql。

- 登录数据库
```shell
cd resource/data

sudo service mysql start # 启动mysql服务
mysql -uroot 			 # 登录mysql的root账户
```

- 基于sql脚本创建database

```sql
CREATE DATABASE translate charset = 'utf8'; # 创建数据库 translate

USE translate;				# 使用translate数据库

SOURCE workbook.sql 		# 执行sql脚本
SOURCE dictionary.sql
```

##### 3. 创建数据库连接 API

本项目是采用 MVC 框架模式进行设计，接下来就来说一说本项目中充当 MVC 的各个角色。

- M：`Translate/slot/slot.py` 中的类，充当 M 角色，负责与数据库进行数据交互
- V：`Translate/model` 中的各个模块，充当 V 角色，负责 UI 界面，展示数据、获取用户输入
- C：本项目中的各个 API 以及信号与槽机制充当 C 角色，负责控制 UI 界面与数据库的交互

打开 sublime 编辑器，编辑 database.py

```python
import pymysql

class DataBase:
    def connect(self, host = 'localhost',port = '3306',user = 'root',password ='123456',db = 'translate'):

        db_config = {
            'host':host,
            'port':port,
            'user':user,
            'password':password,
            'database':db,
            'charset':'utf8'
        }

        try:
            return pymysql.connect(**db_config)
        except:
            raise pymysql.err.MySQLError
```

目的是为了快速导包 编辑 `__init__.py`

```python
from database.database import DataBase
```

##### 4. API 引用

```python
from database import Database

conn = Database.connect()
```

##### `__init__.py` 的目的

- 为了快速导包

在没有加入这行代码之前，假设在 Translate/text.py 中，你需要这样导包：
`from database.database import DataBase`

而加上这行代码之后，你只需这样导包：
`from database import DataBase`

最后，用编辑器打开项目根目录下的 __init__.py，添加以下代码，目的还是为了快速导包。
`import database`



###  翻译 API  

- Translate 目录下的 `__init__.py`
添加代码
`import TranslateAPI`

- API引用方式

```python
from TranslateAPI import Translate

print(Translate.__doc__)

string1 = 'hello world'
result = Translate().translate(string1)
print(result) # 你好，世界
```

### QSSTool 工具

- `QSSTool.py`

```python
class QSSTool:
    @staticmethod
    def qss(self, widget, qss_file = None, qss_file_list = None):
        '''
        :param widget: QSS窗口对象
        :param qss_file: QSS文件
        :param qss_file_list: QSS文件列表
        :return:
        '''

        if qss_file:
            try:
                with open(qss_file, encoding = 'utf-8') as f:
                    widget.setStyleSheet(f.read())
            except:
                print(f"{qss_file} 不存在")

        elif qss_file_list:
            for qss_file in qss_file_list:
                try:
                    with open(qss_file, encoding = 'utf-8') as f:
                        widget.setStyleSheet(f.read())
                except:
                    print(f"{qss_file} 不存在")

        else:
            print("您没有输入QSS文件 或者 输入的QSS文件不存在！")
```

- 同级目录下的 `__init__.py` 文件

`from QSSTool.QSSTool import QSSTool`

- 项目根目录下的 `__init__.py` 文件  添加代码

`import QSSTool`

##### `QSSTool` API 引用方法

```python
from QSSTool import QSSTool

QSSTool.qss(app, 'xxx.qss')
# QSSTool.qss(app, ['aaa.qss', 'bbb.qss', 'ccc.qss'])
```

### Window 基类

项目的翻译界面、查单词界面、背单词界面、文档翻译界面的左侧布局都是一样的，还有菜单栏、状态栏也是一样的，所以我们可以将这些公共部分抽离出来，独立封装成一个模块，作为基类，供其它四个界面继承使用。

##### 基类需要实现的功能

- 实现窗口居中，设置窗口图标、标题和状态栏等属性，窗口大小固定为 680×440px
- 设置左侧功能按钮布局
	- 普通样式：宽高为 100×45px，左边距为 20px，边框圆角为 5px，背景颜色为 #FFEFD5，字体为 500 15px 黑体
	- 选中样式：背景颜色为 #FF8C00，文本颜色为 wheat
- 实现基础的信号与槽机制
- 实现与数据库建立连接

##### 思路分析

Winow 基类需要实现四个功能，对于为什么需要实现这四个功能，解释如下：

- 1）翻译，查字典，背单词、文档翻译界面（以下简称四个界面）都需要设置窗口图标、标题、状态栏、大小，所以基类中封装好，供四个界面继承使用即可
- 2）四个界面左侧的功能按钮是相同的，所以在基类中采用盒子布局中的垂直布局封装就可以，定义好基础样式，供四个界面继承使用即可。至于哪个按钮是选中的，取决于展示哪个界面，可以在四个界面中分别定义
- 3）四个界面都会有切换问题，所以需要定义切换信号，当按钮被点击时，发射信号，外部用槽连接就好
- 4）四个界面都可能需要与数据库建立连接，如果每个都分别与数据库建立连接需要连接四次，而在基类中就与数据库进行连接，则只需要连接一次就好，相对于来说，在基类中就连接数据库更省资源；不仅如此，程序的容错性会更好

**结合上述分析，梳理一下思路，整理如下**：

- 第一步：设置窗口图标、标题和状态栏等属性，窗口大小固定为 680×440px，最大最小宽高在 QSS 样式表中设置
- 第二步：实现窗口居中
- 第三步：实现左侧功能按钮的布局，样式写入 QSS 文件
- 第四步：实现基础的信号与槽机制，分别创建四个界面切换信号
- 第五步：调用数据库 API，实现与数据库建立连接

##### Window 基类的构建

**`__init__(self,parent==None)`中 parent作用**
在PyQt中，所有class都是从QObject派生而来，QWidget对象就可以有一个parent。这种parent-child关系主要用于两个方面：

- 没有parent的QWidget类被认为是最上层的窗体（通常是MainWindow），由于MainWindow的一些操作生成的新窗体对象，parent都应该指向MainWindow。
- 由于parent-child关系的存在，它保证了**child窗体在主窗体被回收之时也被回收**。

###### 1. 在 Window.py 中创建 Window 类，定义好相关方法。

```python
# 创建 Window 类，定义好相关方法。
class Window(QMainWindow):
    """
        所有窗口的基类，
        定义了左侧窗口布局，设计了公用的信号机制和布局接口，菜单形式
    """
    def __init__(self, parent = None,*args,**kwargs):
        suprt().__init__(parent,*args,**kwargs)

    def initUI(self):
        """自定义程序界面"""
        self.__layout()
        self.center()
        ...

    def center(self):
        """窗口居中"""
        ...

    def left_layout(self):
        """
            左侧导航布局
            return QVBoxLayout
        """
        ...

    def __layout(self):
        """窗口整体布局"""
        self.left_layout()
        ...
```

###### 2. 先在 Constant.py 定义窗口常量  `WindowConstants`类， 方便管理

```python
import os

WORK_PATH = os.getcwd()  # 项目工作目录 (返回当前工作目录)

class WindowConstants:

    WINDOW_WORK_PATH = WORK_PATH
    WINDOW_QSS_FILE_PATH = WORK_PATH + '/QSSTool/window.qss'
    
    WINDOW_ICON_PATH = WORK_PATH + '/resource/figs/translate.png'
    WINDOW_EXIT_ICON_PATH = WORK_PATH + '/resource/figs/exit.png'
    WINDOW_EXIT_SHORTCUT = "ctrl+q"

    WINDOW_WELCOM_MESSAGE = "欢迎来到 PyQt5!"
    WINDOW_TITLE = '单词神器'

    WINDOW_WIDTH = 680
    WINDOW_HEIGHT = 400
```

###### 3. 在 `initUI` 方法中引用刚刚设置的常量，设置窗口的属性

```python
    def initUI(self):
        self.statusBar().showMessage(wc.WINDOW_WELCOM_MESSAGE)

        QSSTool.qss(self, wc.WINDOW_QSS_FILE_PATH)
        self.setWindowTitle(wc.WINDOW_TITLE)
        # 设置布局的盒子边距
        self.setContentsMargins(0, 0, 0, 0)
        self.setWindowIcon(QIcon(wc.WINDOW_ICON_PATH))
```

###### 4. 编写 QSS 样式表设置相关属性 `window.qss`

```python
/* 窗口样式 */
QMainWindow {
  min-width: 680px;
  min-height: 440px;
  max-width: 680px;
  max-height: 440px;
}
```

##### 窗口居中

- 在 `center` 方法中实现窗口居中
```python
def center(self):
    """窗口居中"""

    self.resize(wc.WINDOW_WIDTH, wc.WINDOW_HEIGHT)

    screen = QDesktopWidget().screenGeometry()
    size = self.geometry()

    self.move(
        (screen.width() - size.width()) / 2,
        (screen.height() - size.height()) / 2
    )

def initUI(self):
    # 调用窗口居中方法
    self.center()
    ...
```

##### 窗口布局

###### 1. 创建六个按钮，并添加到垂直布局管理器中

```python
def left_layout(self):
    """
        左侧导航布局
        return QVBoxLayout
    """

    btn_name_list = ['翻译', '查词典', '背单词', '译文档', '复制', '收藏']

    vbox = QVBoxLayout()

    for name in btn_name_list:
        b = QPushButton(name)
        b.setCursor(Qt.PointingHandCursor)   # 设置手型
        b.setObjectName('left_btn')
        b.setCheckable(True)

        vbox.addWidget(b)

    return vbox
```

- 右侧布局

```python
def right_layout(self):
    """
    右侧布局，供各个窗口重写此方法自定义右侧布局
    return QVBoxLayout
    """
	...
    vbox = QVBoxLayout()
    return vbox
```

###### 2. 将按钮添加到按钮管理组中，方便管理

```python
self.g = QButtonGroup()

	self.g.addButton(b)
# 默认选中第一个
self.g.buttons()[0].setChecked(True)
```

###### 3. 当按钮点击，需要切换界面，因此需要给按钮绑定点击事件(槽函数)

```python
class Window(QMainWindow):
    # 页面切换信号
    word_translate_page_signal = pyqtSignal()
    search_page_signal = pyqtSignal()
    recite_page_signal = pyqtSignal()
    file_translate_page_signal = pyqtSignal()
    
    ...
    
    # 页面切换信号的槽函数
    def __translate_word_page(self):
        # 翻译按钮槽函数
        self.word_translate_page_signal.emit()

    def __search_word_page(self):
        # 查字典按钮槽函数
        self.search_page_signal.emit()

    def __recite_word_page(self):
        # 背单词按钮槽函数
        self.recite_page_signal.emit()

    def __translate_file_page(self):
        # 译文档按钮槽函数
        self.file_translate_page_signal.emit()

    def copy(self):
        # 复制按钮槽函数
        ...

    def collect(self):
        # 收藏按钮槽函数
        ...
```

###### 4. 绑定槽函数

```python
btn_click_event_list = [
        self.__translate_word_page, 
        self.__search_word_page,
        self.__recite_word_page,
        self.__translate_file_page, 
        self.copy, 
        self.collect,
    ]
    
for name, click_event in zip(btn_name_list, btn_click_event_list):
    b = QPushButton(name)
    
    ...
	# 绑定槽函数
	b.clicked.connect(click_event)
    ...
```

###### 5. 将左侧布局 `left_layout` 和右侧布局`right_layout`添加到窗口布局 `__layout` 中

```python
def __layout(self):
    """窗口整体布局"""

    widget = QWidget()
    # 由于 QMainWindow 中设计了自己的一套布局，贸然添加盒子布局会打破原有的自身的布局，
    # 所以把控件的父类替换成 QWidget，QWidget 将作为所有基础控件的父类
    self.setCentralWidget(widget)

    hbox = QHBoxLayout()                # 中心窗口 水平布局
    left_layout = self.left_layout()
    right_layout = self.right_layout()
    hbox.addLayout(left_layout)
    hbox.addLayout(right_layout)
    
	# hbox.setStretch(int index, int stretch)
    # 左侧布局 : 右侧布局 = 1 : 6
    hbox.setStretch(1, 1)
    hbox.setStretch(2, 6)

    widget.setLayout(hbox)

def initUI(self):
    # 调用布局方法
    self.__layout()
```

###### 6. 编写 QSS 样式表  

- 按钮的默认样式
```qss
#left_btn {
    width: 100px;
    height: 45px;
    margin-left: 20px;
    font: 500 15px "黑体";
    border-radius: 5px;
    background-color: #ffefd5;
}
```

- 按钮的选中样式
```qss
#left_btn:checked {
    background-color: #ff8c00;
    color: wheat;
}
```

- 按钮的滑到样式
```qss
#left_btn:hover {
    ...;
}
```

##### 建立数据库连接

调用数据库 API，实现与数据库建立连接。

- 这一步相对于来说很容易，我们将**连接对象**作为**类属性**供子类使用

```python
class Window(QMainWindow):
    ...
    conn = DataBase.connect()
```

##### 项目 `__init__.py` 配置

> `__init__.py` 是一个 Python 包的标识
> 一个优秀的、多功能的项目，必定有成千上万行的代码，具有高内聚、低耦合、高度模块化的特点，随着模块的增多，对程序员代码管理的能力发起了巨大的挑战。要是过了几天、几月谁也不记得在成千上万行的代码中写了什么，因此我们先要将某类相同或相似的对象封装成类和模块，然后某类相同或相似的模块封装成包，
> 要实现模块和类的**快速导入**，就需要配置` __init__.py` 文件。

**配置 `__init__.py` 的好处**是:

- 能有效的缩短在特定场景中包的导入路径，
- 能简单快速的定位到包的位置，
- 能简便清晰的知道模块所封装的功能和属性

###### 配置项目根目录下的 `__init__.py`

```python
import constants
import database
import model
import QSSTool
import slot
import TranslateAPI
```

###### 配置 constants 包下的 `__init__.py`

```python
from constants.Constants import *
```

###### 配置 database 包下的 `__init__.py`

```python
from database.database import DataBase
```

###### 配置 model 包下的 `__init__.py`

```python
from model.DictTable import TableWidget
from model.Window import Window
from model.TranslateUI import TranslateUI
from model.WordSearchUI import WordSearchUI
from model.ReciteWordUI import ReciteWordUI
from model.TranslateFileUI import TranslateFileUI
```

###### 配置 QSSTool 包下的 `__init__.py`

```python
from QSSTool.QSSTool import QSSTool
```

###### 配置 slot 包下的 `__init__.py`

```python
from slot.slot import *
```

##### 窗口实例化和信号连接

<img src=".\fig\7.窗口实例化和信号连接.png" alt="7.窗口实例化和信号连接" style="zoom:80%;" />

### 翻译界面实现

使用自定义的信号与槽机制，完成翻译界面的数据入库功能。

##### `TranslateUI.py` 基本框架

```python
import sys

from PyQt5.QtCore import Qt, pyqtSignal                         # 基础部件与自定义信号
from PyQt5.QtWidgets import QWidget, QApplication               # 应用和窗体
from PyQt5.QtWidgets import QPushButton, QLineEdit, QTextEdit   # 控件
from PyQt5.QtWidgets import QHBoxLayout, QVBoxLayout            # 布局


from model import Window                                        # Window 基类 （继承）
from TranslateAPI import Translate                              # 翻译API

from slot import CollectSlot, DictionarySlot                    # 自定义槽函数
from QSSTool import QSSTool                                     # QSS样式表
from constants import TranslateConstants as tc                  # 常量配置
```

- TranslateUI 类 框架
```python
# 创建 TranslateUI 类，继承基类
class TranslateUI(Window):

    def __init__(self, parent=None, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.initUI()

    def initUI(self):
        """自定义UI界面"""
        super(TranslateUI, self).initUI()

    def top_layout(self):
        """翻译界面右上侧布局"""
        ...

    def right_layout(self):
        """翻译界面右侧布局"""
        ...

    def translate(self):
        """翻译功能"""
        ...

    def copy(self):
        """复制单词到剪切板"""
        ...

    def collect(self):
        """收藏单词到单词本"""
        ...
        
    def clear(self):
        """清空行编辑器（搜索框）中的内容"""
        ...

    def collect_slot(self, word, means):
        ...

    def search_slot(self, word, means):
        ...
```

- 翻译界面的常量设置
```python
class TranslateConstants:
    """翻译页面常量"""
    TRANSLATE_QSS_FILE_PATH = WORK_PATH + '/QSSTool/translate.qss'
    TRANSLATE_PLACEHODERTEXT = '请输入翻译的词语或语句'

    TRANSLATE_BUTTON_NAME = "翻译一下"
```

##### 布局

- 翻译界面的上侧布局
```python
    def top_layout(self):
        """
            翻译界面上侧布局
            return QHBoxLayout
        """

        hbox = QHBoxLayout()
        hbox.setContentsMargins(0, 10, 0, 0)            # setContentsMargins：设置盒子边距
        
        self.line = QLineEdit(self)                     # self.line 用于后面的 复制 和 收藏 方法
        self.line.setObjectName('line')
        self.line.setPlaceholderText(tc.TRANSLATE_PLACEHODERTEXT)   # 输入提示信息

        clear_btn = QPushButton('清空', self.line)           # "清空"按钮 放到 self.line上面
        clear_btn.setGeometry(330, 0, 60, 45)                # 按钮 在 self.line 上面的 相对位置 setGeometry(x, y,宽,高)
        clear_btn.setCursor(Qt.PointingHandCursor)           # 手型光标

        clear_btn.clicked.connect(self.clear)                # 绑定槽函数

        translate_btn = QPushButton(tc.TRANSLATE_BUTTON_NAME)   # "翻译" 按钮
        translate_btn.setObjectName('translate')
        translate_btn.setCursor(Qt.PointingHandCursor)          # 手型光标

        translate_btn.clicked.connect(self.translate)           # 绑定槽函数

        # 往布局中添加控件 设置伸展模式  
        hbox.addWidget(self.line, stretch=6)        # 输入框：按钮 =  6:1
        hbox.addWidget(translate_btn, stretch=1)

        hbox.setSpacing(5)          # 控件之间的空格间隙

        return hbox
```

- 翻译界面的整体布局

```python
    def right_layout(self):
        """
            翻译界面整体布局
            return QVBoxLayout
        """
        self.text_edit = QTextEdit()                # 翻译结果显示窗口
        self.text_edit.setFocusPolicy(Qt.NoFocus)   # 将文本编辑框设置成不聚焦模式
                                                    # 输入焦点始终不在这个窗体上，即不能进行选中编辑
        vbox = QVBoxLayout()
        vbox.setSpacing(10)                         # 控件之间的空格间隙
        vbox.addLayout(self.top_layout())
        vbox.addWidget(self.text_edit)

        return vbox
```

### 翻译文档界面实现

##### 翻译

- 当点击翻译按钮`translate_btn`时，搜索框`line`中的内容将会被翻译出来，显示在下面的结果显示控件`text_edit`中。
```python
translate_btn.clicked.connect(self.translate)           # 绑定槽函数
```

```python
# 1. 获取搜索框文本
text = self.line.text()
# 2. 调用翻译API进行翻译，并返回翻译结果文本
trans_api = Translate()
translate_text = trans_api.translate(text)
# 3. 将翻译结果文本显示在下方显示框
self.text_edit.setText(translate_text)
```

- 代码优化，考虑 没有翻译出来的情况要给出提示`statusBar()`
```python
    def translate(self):
        """翻译功能
        调用翻译API Translate

            >>> b = Translate()
            >>> b.translate("add a button")
            '添加按钮'

        """
        # 1. 获取搜索框文本
        text = self.line.text()
        # 2. 调用翻译API进行翻译，并返回翻译结果文本
        trans_api = Translate()
        translate_text = trans_api.translate(text)

        if translate_text:
            # 3.1 将翻译结果文本(如果存在)显示在下方显示框
            self.text_edit.setText(translate_text)
        else:
            # 3.2 翻译结果不存在，在状态栏给出提示信息“翻译失败，请重试 ！”
            self.statusBar().showMessage(tc.TRANSLATE_FAILURE_MESSAGE)
```
##### 复制

- 将翻译结果复制单词到剪切板 `QApplication.clipboard()`
```python
    def copy(self):
        """复制单词到剪切板"""
        # 1. 创建剪切板对象
        clipboard = QApplication.clipboard()
        # 2. 获取翻译结果文本
        text = self.text_edit.toPlainText()
        # 3. 如果文本存在，就复制到剪切板
        if text:
            clipboard.setText(text)
            self.statusBar().showMessage(tc.TRANSLATE_COPY_MESSAGE)
```

##### 收藏

- 当点击收藏按钮（基类中的btn）时，我们需要将数据收藏到单词本`wordbook`
```python
	collect_signal = pyqtSignal(str, str)  # 定义收藏信号 （信号发生的时候，实现收藏功能）

    def collect(self):
        """收藏单词到单词本"""
        # 1. 获取当前的待译文本及翻译结果
        word = self.line.text()
        means = self.text_edit.toPlainText()
        # 2. 发射信号，调用槽函数，实现收藏功能
        self.collect_signal.connect(self.collect_slot)
        self.collect_signal.emit(word, means)

    def collect_slot(self, word, means):
        # 调用CollectSlot的to_mysql方法，实现收藏功能
        CollectSlot.to_mysql(self.conn, word, means)
```

- `CollectSlot` 槽函数
```python
class CollectSlot:

    @staticmethod
    def to_mysql(conn, word, means):
        """
            接收3个参数：
                conn：数据库连接对象
                word：单词
                means：意思（翻译结果）
        """
        try:
            with conn.cursor() as cur:
                # 查询单词是否存在单词本中
                sql = 'select id from wordbook where word="%s"' % word
                if cur.execute(sql):
                    return

                # 存入
                sql = 'insert into wordbook(word, means) values("%s", "%s")' % (word, means)
                cur.execute(sql)

            conn.commit()
        except:
            conn.rollback()
```



##### 清空

```python
def clear(self):
    """清空行编辑器（搜索框）中的内容"""

    self.line.clear()
    self.text_edit.clear()
```

##### QSS样式

- `window.qss`  基类样式
```qss
/* 窗口样式 */
QMainWindow {
    min-width: 680px;
    min-height: 440px;
    max-width: 680px;
    max-height: 440px;
}

/* 状态栏样式 */
QStatusBar {
    min-height: 35px;
    background-color:  grey;
    font: 500 15px 黑体;
}

/* 左侧导航按钮样式 */
#left_btn {
    width: 100px;
    height: 45px;
    margin-left: 20px;
    font: 500 15px 黑体;
    border-radius: 5px;
    background-color: #FFEFD5;
}

/* 左侧导航按钮选中样式 */
#left_btn:checked {
    width: 100px;
    height: 45px;
    margin-left: 20px;
    font: 500 18px 黑体;
    border-radius: 5px;
    background-color: #FF8C00;
    color: wheat;
}
```

- `translate.qss` 翻译界面样式
```qss
/* 行编辑器样式 */
#line {
  height: 45px;
  padding-left: 15px;
  margin-left: 15px;
  margin-right: 20px;
  font: 500 18px 黑体;
  border: solid 5px red;
  border-radius: 5px;
  background-color: wheat;
}

/* 行编辑器中清空按钮样式 */
#line QPushButton {
  color: #e6e6e6;
  background-color: #808080;
  margin-right: 0;
}

/* 翻译按钮样式 */
#translate {
  height: 45px;
  min-width: 100px;
  margin-right: 20px;
  font: 500 16px 黑体;
  border: solid 5px red;
  border-radius: 5px;
  background-color: blue;
  color: white;
}

/* 文本编辑器样式 */
QTextEdit {
  min-width: 380px;
  max-height: 300px;
  margin-left: 15px;
  margin-top: 5px;
  margin-right: 20px;
  margin-bottom: 12px;
  font: 500 15px 黑体;
  border: solid 5px black;
  border-radius: 5px;
  outline: none;
}
```

- QSS样式加载到界面
```python
def initUI(self):
    super(TranslateUI, self).initUI()
    QSSTool.qss(self, tc.TRANSLATE_QSS_FILE_PATH)
    self.show()
```

### 译文档界面

#### 框架

```python
class TranslateFileUI(Window):

    bt = Translate()

    def __init__(self, parent=None, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.initUI()

    def initUI(self):
        super(TranslateFileUI, self).initUI()

    def top_layout(self):
        """上部布局"""
        ...

    def right_layout(self):
        """右侧整体布局"""
        ...

    def loadText(self):
        """加载文档"""
        ...

    def translate_file(self):
        """翻译文档"""
        ...

    def __clear_text(self):
        """清空控件内容"""
        ...
```

##### 布局

- 上部按钮布局
```python
def top_layout(self):
    """上部布局"""
    hbox = QHBoxLayout()                    # 按钮 水平布局
    hbox.setSpacing(20)                     # 按钮之间的间隔
    hbox.setContentsMargins(12, 10, 15, 0)  # 边距

    # 创建按钮
    names = ['加载文档','清空','翻译']
    obj_names = ['file_btn','clear_btn','translate_btn']
    cliecked_events = [self.loadText, self.__clear_text, self.translate_file]

    for name,obj_name,cli_event in zip(names, obj_names,cliecked_events):
        btn = QPushButton(name)                     # 按钮控件实例化
        btn.setObjectName(obj_name)                 # 设置 objectname
        btn.setCursor(Qt.PointingHandCursor)        # 设置手型
        btn.clicked.connect(cli_event)              # 绑定点击事件
        hbox.addWidget(btn)                         # 添加到布局

    return hbox
```

- 整体布局

```python
    def right_layout(self):
        """整体布局"""
        self.text_edit = QTextEdit()
        self.result_widget = QTextEdit()

        self.text_edit.setObjectName('text_edit')
        self.result_widget.setObjectName('result_widget')
        self.result_widget.setCursor(Qt.PointingHandCursor)

        vbox = QVBoxLayout()
        vbox.setContentsMargins(5, 10, 15, 0)
        # 布局上中下三部分所占空间比为 1:4:4
        vbox.addLayout(top_layout(), stretch = 1)
        vbox.addWidget(self.text_edit, stretch = 4)
        vbox.addWidget(self.result_widget, stretch = 4)
        return vbox
```

##### 实现加载文档功能

```python
def loadText(self):
    """加载文档"""
    dialog = QFileDialog()
    # 获取选中文件绝对路径
    file_path = dialog.getOpenFileName(self, "选取文件", tfc.TRANSLATEFILE_FILE_PATH, "Text Files(*.txt)")[0]

    if file_path:
        with open(file_path, encoding='utf-8') as f:
            data = f.read()
            self.text_edit.setText(data)
```



##### QSS样式

- `translatefile.qss`
```qss
/* 文件选择按钮、翻译按钮样式 */
#file_btn,
#clear_btn,
#translate_btn {
  min-height: 30px;
  max-width: 140px;
  border: 2px solid #5e5e5e;
  border-radius: 5px;
  font: 500 15px 黑体;
  background-color: #a2945e;
  color: #d5d5d5;
}

/* 文件选择按钮、翻译按钮样式点击样式 */
#file_btn:pressed,
#clear_btn:pressed,
#translate_btn:pressed {
  background-color: blue;
  color: white;
}

/* 文本编辑框样式 */
#text_edit {
  border: 2px solid #5e5e5e;
  border-radius: 5px;
  font: 400 14px 黑体;
}

/* 展示翻译结果的标签样式 */
#result_widget {
  border: 2px solid #5e5e5e;
  border-radius: 5px;
  font: 400 14px 黑体;
}
```

##### 调用翻译的API, 实现翻译功能

```python
    def translate_file(self):
        """翻译文档"""
        # 1. 获取待翻译文档
        text = self.text_edit.toPlainText()
        # 2. 调用翻译API进行翻译
        if text:
            text_list = [[j for j in i.split('。') if j] for i in text.split('\n')]
            result = ''
            for x in text_list:
                y = [self.trans_api.translate(i) for i in x] # 逐句翻译
                result += ''.join(y) + '\n'                  # 翻译结果整合
            self.result_widget.setText(result)
        else:
            self.statusBar().showMessage(tfc.TRANSLATEFILE_FAILURE_MESSAGE)
```

##### 实现清空功能

```python
def __clear_text(self):
    """清空控件内容"""
    self.text_edit.clear()
    self.result_widget.clear()
```

### 查词典界面实现

#### 个性化表格控件

##### 框架

```python
class TableWidget(QWidget):

    def __init__(self, *args, **kwargs):

        # API: count：数据库中的总条数 data：8条初始数据
        # 父类中不需要 count 和 data 参数，所以需要 pop
        if kwargs.get('count') is not None:
            count = kwargs.pop('count')
        else:
            count = 0

        if kwargs.get('data') is not None:
            self.data = kwargs.pop('data')
        else:
            self.data = ()

        # 计算总页数
        if count and count % tc.TABLE_DATA_SHOW_COUNT == 0:
            self.page = count // tc.TABLE_DATA_SHOW_COUNT
        else:
            self.page = count // tc.TABLE_DATA_SHOW_COUNT + 1


    def initUI(self):

    def __layout(self):
        """整体布局"""
        ...

    def page_layout(self):
        """页码布局"""
        ...
```

##### 整体布局

- 在布局管理器中添加表格控件，并设置表头、自动拉伸、表头高度、单行选中、禁止编辑、表格行高等属性。

```python
    def __layout(self):
        """
            表格布局 和 Window.py 的 __layout 方法不一样，
            注意区别，这里是自定义表格控件的布局方法
        """
        self.table = QTableWidget(tc.TABLE_DEFAULT_ROW, tc.TABLE_DEFAULT_COLUMN)    # 8行3列
        self.table.setHorizontalHeaderLabels(tc.TABLE_HEADER_LIST)                  # 表头
        self.table.horizontalHeader().setFixedHeight(tc.TABLE_HEADER_HEIGHT)        # 表头高度
        for i in range(tc.TABLE_DEFAULT_ROW):                                       # 设置行高
            self.table.setRowHeight(i, tc.TABLE_ROW_HEIGHT)
        self.table.setSelectionMode(QAbstractItemView.SingleSelection)              # 只能选中一行
        self.table.setEditTriggers(QTableView.NoEditTriggers)                       # 不可编辑
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)               # 设置只有行选中
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)     # 列自动拉伸，充满界面
        
        vbox = QVBoxLayout()
        vbox.addWidget(self.table)              # 表格
        vbox.addLayout(self.page_layout())      # 页码

        return vbox
```

##### 页码布局

- 设置底部的页码控制器的创建相应的按钮。
```python
    def page_layout(self):
        """页码布局"""
        # 单击 想要到达的页数
        home_page = QPushButton("首页")
        last_page = QPushButton("<上一页")
        page1 = QPushButton("1")
        page2 = QPushButton("2")
        page3 = QPushButton("3")
        page4 = QPushButton("4")
        page5 = QPushButton("5")
        next_page = QPushButton("下一页>")
        finally_page = QPushButton("尾页")

        # 创建按钮组
        self.group = QButtonGroup(self)
        btn_list = [page1, page2, page3, page4, page5]
        for b in btn_list:
            self.group.addButton(b)
            b.setCheckable(True)
        self.group.buttons()[0].setChecked(True)

        self.total_page = QLabel("共" + str(self.page) + "页")
        # 手动输入 达到的页数
        skip_to = QLabel("跳到")
        self.skip_page = QLineEdit()
        skip_page_to = QLabel("页")
        confirm = QPushButton("确定")

        # 将控件添加到布局中
        hbox = QHBoxLayout()
        hbox.setSpacing(0)
        w_list = [
            home_page, last_page, page1, page2,
            page3, page4, page5, finally_page,
            next_page, self.total_page, skip_to, self.skip_page,
            skip_page_to, confirm
        ]
        objectname_list = [
            'home_page', 'last_page', 'page1', 'page2',
            'page3', 'page4', 'page5', 'finally_page',
            'next_page', 'total_page', 'skip_to', 'skip_page',
            'skip_page_to', 'confirm'
        ]

        for w, objectname in zip(w_list, objectname_list):
            w.setObjectName(objectname)
            hbox.addWidget(w)

        return hbox
```

##### 设置 "操作" 按钮

- 表格操作这一栏还需要给每一行添加 3 个创建，三个按钮可以用一个水平布局管理器来管理，然后将布局添加到 QWidget，最后返回 QWidget 对象。这里将布局添加到 QWidget 对象中，貌似有点多余，但是可以想一想，表格控件中的每个 item 并没有添加布局的方法，所以我们需要借助 QWidget 对象，到时只需要通过表格控件的 setCellWidget 方法，将 setCellWidget 添加进去就可以了。

```python
    # 对表格中的数据进行操作
    def oparate(self, row):
        """设置 "操作" 按钮"""
        
        hbox = QHBoxLayout()
        hbox.setContentsMargins(0, 0, 0, 0)
        hbox.setSpacing(0)

        btn_name_list = ['删除', '修改', '复制']
        btn_objectname_list = ['delete', 'update', 'copy']
        btn_click_event_list = [self.__delete, self.__update, self.__copy]

        for btn_name, btn_objectname, btn_click_event in zip(
                btn_name_list, btn_objectname_list, btn_click_event_list):

            btn = QPushButton(btn_name)
            btn.setObjectName(btn_objectname)
            btn.clicked.connect(btn_click_event)

            btn.setMinimumSize(50, 39)
            btn.setCursor(Qt.PointingHandCursor)
            btn.row = row

            hbox.addWidget(btn)

        widget = QWidget()
        widget.setLayout(hbox)
        return widget
```
##### 数据展示

```python
    def data_show(self):
        """每页的数据展示"""
        self.table.clearContents()

        row_num = min(len(self.data), 8)
        for row in range(row_num):
            word, means = self.data[row]

            word_item = QTableWidgetItem(word)
            means_item = QTableWidgetItem(means)

            word_item.setTextAlignment(Qt.AlignCenter)      # 文本居中
            means_item.setTextAlignment(Qt.AlignCenter)
            # col0: word_item; col1: means_item; col2: self.oparate(row)
            self.table.setItem(row, 0, QTableWidgetItem(word_item))
            self.table.setItem(row, 1, QTableWidgetItem(means_item))
            self.table.setCellWidget(row, 2, self.oparate(row))
```

##### 表格行操作：删除、修改、复制

- 删除

```python
delete_signal = pyqtSignal(str)             # 删除信号

def __delete(self):
	"""删除操作按钮点击事件"""
	row = self.sender().row
	word = self.table.item(row, 0).text()
	self.delete_signal.emit(word)       # 发出"删除"信号
	self.changeTableContent()
```

- 修改

```python
update_signal = pyqtSignal(str, str)        # 修改信号

def __update(self):
    """修改操作按钮点击事件"""
    row = self.sender().row
    word = self.table.item(row, 0).text()

    text, ok = QInputDialog.getText(self, "修改", "请输入修改内容：", QLineEdit.Normal, "")
    if ok and text:
        self.update_signal.emit(text, word) # 发出"修改"信号
    self.changeTableContent()
```

- 复制

```python
copy_signal = pyqtSignal(str)               # 复制信号

def __copy(self):
    """复制操作按钮点击事件"""
    row = self.sender().row
    word = self.table.item(row, 0).text()
    means = self.table.item(row, 1).text()
    text = word + ':' + means

    clipboard = QApplication.clipboard()    # 实例化剪切板对象
    clipboard.setText(text)

    self.copy_signal.emit(text)             # 发出"复制"信号
```

##### 实现页码控制

- 我们需要实现它翻页的功能。关于页码的跳转，不管哪个按钮被按下，表格的内容都应该会发生改变，因此我们可以定义一个内容改变信号，供外界连接更新数据，内部调用 data_show 方法

- 刷新页面
```python
change_signal = pyqtSignal(str)             # 内容改变信号

def changeTableContent(self):
    """发射当前页表格内容改变信号"""
    btn = self.group.checkedButton()
    self.change_signal.emit(btn.text())

    self.data_show()
```

- 首页跳转

```python
home_page.clicked.connect(self.__home_page)

def __home_page(self):
    """点击首页信号"""
    buttons = self.group.buttons()

    for i in range(5):
    buttons[i].setText(str(i+1))
    buttons[0].setChecked(True)

    self.changeTableContent()
```

- 尾页跳转
我们需要先计算出共有多少页才能跳转到尾页，要不然跳转到的尾页不是真正的最后一页

```python
finally_page.clicked.connect(self.__finally_page)

def __finally_page(self):
    """点击尾页信号"""
    total_page = self.total_page.text()[1:-1]   # 获取总页数
    buttons = self.group.buttons()

    if int(total_page) <= 5:                    
    p = range(1, 6)
    else:                                       # 获取最后5页的页码
    p = range(int(total_page) - 4, int(total_page) + 1)

    for i in range(5):
    buttons[i].setText(str(p[i]))

    buttons[-1].setChecked(True)                # 选中最后一页
    self.changeTableContent()
```

- 实现上一页跳转功能

```python
last_page.clicked.connect(self.__last_page)

def __last_page(self):
    """点击 上一页 信号"""
    # 获取页码和当前页按钮位置
    buttons = self.group.buttons()
    for b in buttons:
        if b.isChecked():       # 当前页按钮位置
            page = b.text()
            index = buttons.index(b)
            break

    if page == '1':
        QMessageBox.information(self, "提示", "已经是第一页了", QMessageBox.Yes)
        return

    # 如果是第一个按钮被选中则页码减一，否则前一个按钮被选中
    if index == 0:
        p = range(int(page) - 1, int(page) + 4)     # 页码往前移动一位

        for i in range(5):
            buttons[i].setText(str(p[i]))

        buttons[index].setChecked(True)
    else:
        buttons[index-1].setChecked(True)
    self.changeTableContent()
```

- 下一页跳转功能

- 通过输入方式跳转

##### QSS

- `dicttable.qss`
```QSS
QTableWidget {
    background-color:rgb(240,240,240);
    color: #1A1A1A;
    selection-background-color: #ffcc33;
    selection-color: deepgray;
}

QHeaderView::section {
    border: 1px solid gray;
    font: 500 15px 黑体;
}
```


#### 查单词界面实现

##### 查单词界面框架

- 基于前面的自定义表格控件，完善查单词界面
```python
class WordSearchUI(Window):

    def __init__(self, parent=None, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.initUI()

    def initUI(self):
        super().initUI()

    def right_layout(self):
        """右侧布局
        放入自定义的表格控件
        """
        self.table = TableWidget(data, page)
        vbox = QVBoxLayout()
        vbox.addWidget(self.table)
        return vbox

    def table_content_change(self, page):
        """表格翻页"""
        ...

    def table_content_delete(self, word):
        """表格内容删除"""
        ...

    def table_content_update(self, means, word):
        """表格内容修改"""
        ...

    def table_content_copy(self, text):
        """表格内容复制"""
        ...
```

##### GetWord槽函数

```python
class GetWord:
    """获取单词"""
    @staticmethod
    def from_mysql(conn, page=1):
        """
            接收2个参数：
                conn：数据库连接对象
                page：(int or str) 页数 每页8个
        """
        data = ()
        # -------------- 容错处理 ---------------- #
        if isinstance(page, str):
            page = int(page)
        if not(isinstance(page, int) or isinstance(page, str)):
            return data
        # -------------------------------------- #

        try:
            with conn.cursor() as cur:
                # 在数据库库中查询 8 条数据
                sql = 'select word,means from dictionary where is_delete=0 and id>%s limit 8' % ((page - 1)*8)
                cur.execute(sql)
                data = cur.fetchall()

            conn.commit()
        except:
            conn.rollback()

        return data


    @staticmethod
    def all_count(conn):
        """
            接收1个参数：
                conn：数据库连接对象
        """
        count = 0
        try:
            with conn.cursor() as cur:
                # 查询单词
                sql = 'select count(id) from dictionary where is_delete=0'
                cur.execute(sql)
                count = cur.fetchone()[0]
            conn.commit()
        except:
            conn.rollback()

        return count
```

##### 连接表格控件内部传递出来的信号

- 自定义表格控件的内部信号

```python
class TableWidget(QWidget):

    delete_signal = pyqtSignal(str)             # 删除信号
    update_signal = pyqtSignal(str, str)        # 修改信号
    copy_signal = pyqtSignal(str)               # 复制信号

    change_signal = pyqtSignal(str)             # 内容改变信号
    ...
```

- 连接表格控件内部传递出来的数据更新信号、单词更改信号、单词删除信号和单词复制信号

```python
    def initUI(self):
        super().initUI()
        # 连接信号，绑定槽
        self.table.change_signal.connect(self.table_content_change)
        self.table.update_signal.connect(self.table_content_update)
        self.table.delete_signal.connect(self.table_content_delete)
        self.table.copy_signal.connect(self.table_content_copy)

    def right_layout(self):
        """右侧布局
        放入自定义的表格控件
        - 外部定义GetWord槽函数用于获取mysql数据
        """
        self.table = TableWidget(count = GetWord.all_count(self.conn), 
                                 data = GetWord.from_mysql(self.conn))
        self.table.setObjectName('widget')

        vbox.addWidget(self.table)
        return vbox
```

##### 页面数据更新

- 每次数据更新时，我们只需要传入 page 参数调用 from_mysql 方法即可

```python
def table_content_change(self, page):
    """表格翻页"""
    self.table.data = GetWord.from_mysql(self.conn, page=page)
```

##### 表格内容修改
- 实现单词修改槽函数，我们需要将修改的数据提交到数据库实时更新

```python
class UpdateMean:
    """修改单词意思"""
    @staticmethod
    def update(conn, means, word):
        """
            接收3个参数：
                conn：数据库连接对象
                word：单词
                means：意思（翻译结果）
        """
        status = 0      # 修改失败，status的值就仍然是 0 
        try:
            with conn.cursor() as cur:
                # 修改数据库表格，修改单词的意思
                sql = 'update dictionary set means="%s" where word="%s"' % (means, word)
                status = cur.execute(sql)
            conn.commit()
        except:
            conn.rollback()

        return status
```

- 调用 update 方法，得到修改的状态，如果修改失败弹出一个消息盒子，告知用户

```python
def table_content_update(self, means, word):
    """表格内容修改"""
    status = UpdateMean.update(self.conn, means = means, word = word)
    if not status:  # 修改失败，弹出提示框
        QMessageBox.warning(
            self, '警告', '修改错误',
            QMessageBox.No | QMessageBox.Yes,
            QMessageBox.Yes
        )
    else:           # 显示，'单词意思修改成功！'
        self.statusBar().showMessage(sc.SEARCH_UPDATE_MESSAGE)
```

##### 删除单词

- 实现单词删除槽函数，我们需要将要删除的数据提交到数据库实时更新，可以在 `slot.py`中定义一个专门用来删除的方法，不管修改成功与否，都返回删除状态。

```python
class DeleteWord:
    """删除单词"""
    @staticmethod
    def delete(conn, word):
        """
            接收2个参数：
                conn：数据库连接对象
                word：单词
        """
        status = 0
        try:
            with conn.cursor() as cur:
                # 查询单词
                sql = 'update dictionary set is_delete = 1 where word="%s"' % word
                status = cur.execute(sql)
            conn.commit()
        except:
            conn.rollback()

        return status
```

- 表格内容删除

```python
def table_content_delete(self, word):
    """表格内容删除"""
    status = DeleteWord.delete(self.conn, word = word)
    if not status:
        QMessageBox.warning(
            self, '警告', '删除错误',
            QMessageBox.No | QMessageBox.Yes,
            QMessageBox.Yes
        )
    else:
        self.statusBar().showMessage(sc.SEARCH_DELETE_MESSAGE)
```

##### 表格复制

```PYTHON
def table_content_copy(self, text):
    """表格内容复制"""
    self.statusBar().showMessage(sc.SEARCH_COPY_MESSAGE)
```

### 背单词界面

**思路分析**

1）窗口居中，设置窗口大小、图标、标题和状态栏等属性与左侧布局只需要继承 Window 基类即可，在 Window 基类中我们已经完成了窗口属性设置和左侧功能按钮的布局设置。

2）右侧布局的思路分析如下：

- 布局分析：从效果图中可以看出右侧布局分为上中下三部分，上部分可以选用一个控件，中间部分可以选用垂直布局管理器来管理，下部分可以选用水平布局管理器来管理，然后将控件和布局添加到右侧布局中
- 控件选择：上部分可以选一个标签控件来显示单词；中间可以选用标签控件来显示 A、B、C、D，用按钮控件显示选项，然后将按钮控件设置为标签控件的父级；下部分选用按钮即可
- 布局管理：我们可以通过基类中留有的 API，重写 right_layout 方法，然后将控件和布局添加到右侧布局中

3）答案验证功能的实现：当点击中间的选项时，我们需要从数据库中查找正确的答案，如果选项中文本和正确答案一样，则正确，否则则错误。

4）答案正确、错误样式处理：如果答案正确，则选中的按钮设置为绿色，错误就设置成红色。

5）上一个、下一个翻页功能的实现：当点击上一个或下一个按钮时，我们需要切换单词。首先可以从数据库中取出一组数据，然后借助队列进行处理，这里是一个难点。

6）答案获取功能的实现：当点击不认识按钮时，我们需要从 wordbook 表中， 找出该单词的正确意思。

7）单词删除功能的实现：当点击腰斩按钮时，我们需要从 wordbook 表中，删除该单词，为了数据的完整性，我们可以采用逻辑删除的方式删除数据，将 is_delete 字典设置为 1 即可。

##### 布局

```python
class ReciteWordUI(Window):

    def __init__(self, parent=None, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.initUI()

    def initUI(self):
        super(ReciteWordUI, self).initUI()

    def top_layout(self):
        """上边布局"""
        ...

    def mid_layout(self):
        """中间布局"""
        ...

    def bottom_layout(self):
        """下边布局"""
        ...

    def right_layout(self):
        """整体布局"""
        ...
```

- 布局实现

```python
class ReciteWordUI(Window):

    def __init__(self, parent=None, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.initUI()

    def initUI(self):
        super(ReciteWordUI, self).initUI()
        QSSTool.qss(self, rc.RECITE_QSS_FILE_PATH)  # QSS

    def top_layout(self):
        """上边布局
        显示 要背的单词
        """
        self.label = QLabel()
        self.label.setObjectName('label')
        self.label.setAlignment(Qt.AlignCenter)     # 设置文本居中对齐
        hbox = QHBoxLayout()
        hbox.addWidget(self.label)
        return hbox

    def mid_layout(self):
        """中间布局
        显示 A,B,C,D 四个选项
        """
        answer_names = ['A', 'B', 'C', 'D']
        answer_objnames = ['answer_a', 'answer_b', 'answer_c', 'answer_d']
        btn_objnames = ['btn_a', 'btn_b', 'btn_c', 'btn_d']

        self.vbox = QVBoxLayout()
        self.group_opt = QButtonGroup()
        
        for name, ans_objname, btn_objname in zip(answer_names, answer_objnames, btn_objnames):
            # 选项按钮
            option_btn = QPushButton()
            option_btn.setObjectName(btn_objnames)
            option_btn.setCursor(Qt.PointingHandCursor) # 手型
            option_btn.setCheckable(True)
            # 在选项按钮上放置标签
            label = QLabel(name, option_btn)
            label.setAlignment(Qt.AlignCenter)          # 居中
            label.setObjectName(ans_objname)

            self.group_opt.addButton(option_btn)        # 选项按钮加入按钮组管理
            self.vbox.addWidget(option_btn)             # 加入布局管理        

        return self.vbox

    def bottom_layout(self):
        """下边布局
        操作按钮： '上一个'、'不认识'、'腰斩'、'下一个'
        """
        btn_names = [
            rc.RECITE_PREV_BUTTON_NAME, rc.RECITE_UNKW_BUTTON_NAME,
            rc.RECITE_KILL_BUTTON_NAME, rc.RECITE_NEXT_BUTTON_NAME
        ]
        btn_objnames = ['pre', 'unkwon', 'kill', 'next']

        hbox = QHBoxLayout()
        hbox.setSpacing(5)      # 控件之间的间距
        for name, object_name in zip(btn_names, btn_objnames):
            b = QPushButton(name)
            b.setObjectName(object_name)
            b.setCursor(Qt.PointingHandCursor)
            hbox.addWidget(b)
        return hbox

    def right_layout(self):
        """整体布局
        合并 上、中、下 界面，垂直布局管理
        """
        vbox = QVBoxLayout()
        vbox.setContentsMargins(12, 10, 20, 10)
        vbox.setSpacing(0)

        # 上、中、下布局占据空间比为 3:5:1
        vbox.addLayout(self.top_layout(), stretch=3)
        vbox.addLayout(self.mid_layout(), stretch=5)
        vbox.addLayout(self.bottom_layout(), stretch=1)

        return vbox
```


```python

```

##### 实现上一个、下一个翻页功能

我们采用队列类存储数据

- 用一个先进先出队列来存储下一个按钮对应的数据，
- 用一个先进后出队列来存储上一个按钮对应的数据

当点击“上一个”或“下一个”按钮时都需要重构队列，我们可以用 self.queue 队列中的数据，将原有的 queue_prev 和 queue_next 释放掉重新创建
```python
def __queue_struct(self, data):
    """队列重构 更新上一个、下一个单词队列"""
    # data 是当前页面中加载出来的一个单元数据

    for x in self.queue.queue:
        if data == x:
            w = list(self.queue.queue)
            index = w.index(x)
            prev_list = w[:index]
            next_list = w[index + 1:]

    self.queue_next = Queue(rc.RECITE_QUEUE_SIZE)
    self.queue_prev = LifoQueue(rc.RECITE_QUEUE_SIZE)

    for x in prev_list:
        self.queue_prev.put(x)
    for x in next_list:
        self.queue_next.put(x)
```

- 点击“下一个”按钮时，从 queue_next 取出一个数据，然后重构队列
```python

```

- 当 queue_next 队列中没有数据了需要更新 queue 队列
```python
def refresh(self):
    """数据更新"""

    # 这里起到清空队列的作用，self.queue一直是满队列，不清空数据将插不进去，
    # 会导致程序处于阻塞状态
    self.queue = Queue(rc.RECITE_QUEUE_SIZE)

    self.__data_process()
```

##### 答案获取功能



##### QSS
```QSS
/* 上侧布局 */
#label {
    font: 500 30px "黑体";
    border-radius: 5px;
    background-color: #D5D5D5;
    border: 2px groove #666666;
    color: #3333ff;
    margin-bottom: 15px;
}


/* 中间布局 */
/* 标签样式 */
#answer_a, #answer_b, #answer_c, #answer_d {
    min-width: 40px;
    min-height: 35px;
    border: 2px groove gray;
    font: 500 16px Arial;
    border-top-left-radius: 5px;
    border-bottom-left-radius: 5px;
    text-align: center;
    margin-bottom: 10px;
}

/* 按钮样式 */
#btn_a, #btn_b, #btn_c, #btn_d {
    min-width: 450px;
    min-height: 35px;
    border-top: 2px groove gray;
    border-right: 2px groove gray;
    border-bottom: 2px groove gray;
    margin-left: 40px;
    border-top-right-radius: 5px;
    border-bottom-right-radius: 5px;
    text-align: left;
    padding-left: 13px;
    font: 500 12px "黑体";
    margin-bottom: 10px;
}

/* 鼠标滑到样式 */
#answer_a:hover, #answer_b:hover, #answer_c:hover, #answer_d:hover,
#btn_a:hover, #btn_b:hover, #btn_c:hover, #btn_d:hover {
    background-color: #FFD699;
}


/* 下侧布局 */
#pre, #unkwon, #kill, #next {
    min-height: 35px;
    border: 2px groove #666666;
    border-radius: 5px;
    margin-top: 15px;
    font: 500 12px 黑体;
}

/* 按钮滑到样式 */
#pre:hover, #unkwon:hover, #kill:hover, #next:hover {
    background-color: #ff9966;
}

/* 按钮点击样式 */
#pre:pressed, #unkwon:pressed, #kill:pressed, #next:pressed {
    background-color: blue;
    color: white;
}
```
### main 程序入口设计

- 框架
```python
import sys

from PyQt5.QtWidgets import QApplication

from model import TranslateUI, WordSearchUI, ReciteWordUI, TranslateFileUI


class WindowShow:

    def __init__(self):
        app = QApplication(sys.argv)

        self.translate_ui = TranslateUI()
        self.search_ui = WordSearchUI(self.translate_ui)
        self.recite_ui = ReciteWordUI(self.translate_ui)
        self.translate_file_ui = TranslateFileUI(self.translate_ui)

        self.search_ui.move(232, 208)
        self.recite_ui.move(232, 208)
        self.translate_file_ui.move(232, 208)

        self.switch()

        sys.exit(app.exec_())

    def show_translate_ui(self):
        """展示翻译界面"""
        ...

    def show_search_ui(self):
        """展示查单词界面"""
        ...

    def show_recite_ui(self):
        """展示背单词界面"""
        ...

    def show_translate_file_ui(self):
        """展示译文档界面"""
        ...

    def switch(self):
        """页码切换"""
        ...
```

### tips --  Python 队列

- 在 `queue` 模块下有四种队列，先进先出队列、后进先出队列、优先级队列和双线队列

|队列方式	|特点|
|queue.Queue	|先进先出队列|
|queue.LifoQueue	|后进先出队列(stack)|
|queue.PriorityQueue	|优先级队列|
|queue.deque	|双线队列|

- **队列数据操作方法**
put：存入数据，Queue.put() 默认有 block=True 和 timeout 两个参数。当 block=True 时，如果当时是满队列，队列的数据写入操作是阻塞的，阻塞的时间由 timeout 决定
get：取出一个数据，如果是个空队列，默认是阻塞状态的
empty：判断队列是否为空，返回 True 或 False
qsize：获取队列的大小
maxsize：队列的最大长度，即满队列时队列中元素的个数
full：判断是否为满队列

##### 先进先出队列 `queue.Queue`

```python
from queue import Queue

q=Queue(maxsize=4)    # 如果不设置长度，默认为无限长
print(q.maxsize)      # 4
q.put(123)
q.put(456)
q.put(789)
print(q.get())        # 123
print(q.get())        # 456
```

##### 先进后出队列 `queue.LifoQueue`

- stack
```python
from queue import LifoQueue

q=LifoQueue(maxsize=4)    # 如果不设置长度，默认为无限长
print(q.maxsize)      # 4
q.put(123)
q.put(456)
q.put(789)
print(q.get())        # 789
print(q.get())        # 456
```